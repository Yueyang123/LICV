C语言的陷阱与缺陷

陷阱

(一)词法陷阱
1.C语言中‘=’是赋值，‘==’是比较

2.&，|不同与&&和||

& 按位与
| 按位或
&&
||逻辑运算符

3.在使用除法的时候商要慎用取地址符号
在C编译器中采用的是贪心法读取文本在读取到‘/*’将直接退出本句。
y=x/*p
===>y=x

4.在负数的赋值问题中
a=-1有可能被一些老版编译器理解为理解为a=- 1===>a-=1;


5.字符与字符串

单引号的字符实际代表一个整数
双引号引起的字符串在实际上代表一个指向无名数组的指针。该数组将被双引号中的所有元素与一个值为0的字符‘/0’初始化

如果‘’中有超过一个字符，现代编译器一般会用后一个字符覆盖前一个字符
‘yes’将被直接作为‘s’

（二）语法陷阱

1.函数申明

float *g(),(*h)()

g 是一个函数
h 是一个函数指针

2.运算符优先级的问题

    1).任何逻辑运算符优先级低于关系运算符
    2).移位运算符优先级比算数运算符低，但是比关系运算符要高

在不确认函数的优先级的时候请加括号


（1）if(flag&FLAG)
    if(flag& FLAG!=0)将被编译器错误的理解为
    if(flag&(FLAG!=0))

（2）1/2*a 含义是(1/2)*a
            而不是1/(2*a)

3.注意分号

在C程序中有时多加一个分号会产生不良后果，
有时这个错误无法被编译器检查出来

4.switch 语句

C语言中将case 标号作为真正意义上的标号，控制流程会直接通过case。
也就是说当你的case语句不加上break;语句将刀支程序一直执行。其他case语句中的内容也可能被执行。如果是有意为之一定要写注释。

5.函数调用

C语言要求函数调用的时候及时不带参数，也应包括参数列表。
f是一个函数
f();
不能写作f,函数将不会被调用。

6.悬挂的else
if(x==0)
    if(y==0) error();
else
{
    z=x+y;
    f(&z);
}
将被编译器理解为
if(x==0){
            if(y==0) error();
            else
            {
                z=x+y;
                f(&z);
            }
}
如果想要避免这种情况最好写作
6.悬挂的else
if(x==0)
{
    if(y==0) 
    error();
}
else
{
    z=x+y;
    f(&z);
}

（三）语义陷阱







